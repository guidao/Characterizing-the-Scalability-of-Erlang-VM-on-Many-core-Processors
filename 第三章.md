##第三章
##erlang运行时系统

当前的BEAM虚拟机是一个erlang的独立的虚拟机，最初叫着Turbo erlang。它是一个高效的基于寄存器的虚拟机。首次实验性的实现SMP（并发）虚拟机是在1998年，当时它作为一个硕士毕业项目。在2006年，这个SMP虚拟机并合并的官方的发布版中。

这SMP erlang虚拟机是一个多线程程序。在linux上，它利用了POSIX线程库。线程在共享着进程的内存。一个erlang调度器是一个线程，它调度并执行erlang程序和端口。它既是一个调度器，也是一个工作者。调度和执行进程和端口是交差的。每个一个调度器都有分离的运行队里来存储可运行的进程和端口。在many-core处理器上，erlang虚拟机通常被配置为一个核心一个调度器或者如果硬件多线程支持的话，一个硬件线程一个核心。

erlang虚拟机系统提供了大量的特性（通常跟操作系统有关），例如：内存管理，进程调度，网络等。在剩下的章节里，我们将详细介绍且分析当前SMP虚拟机的实现的不同部分。这些都与many-core处理器的可扩展性有关。包括进程结构，消息传递，调度，同步和内存管理。

###3.1 erlang进程结构

每一个erlang进程都包含一个进程控制块（PCB），一个栈和一个私有堆。一个PCB是一个数据结构，其他包含进程管理信息，例如进程ID，栈和堆的位置，寄存器参数和程序计数。在堆中，或许存在一些小的堆碎片，它们会在每一次内存垃圾回收后合并到主堆。堆碎片被用于堆中没有足够的自由空间并且执行垃圾回收不能得到更多的自由内存。例如：当一个进程发送一个消息给另外一个进程。如果接受进程没有足够的堆空间来存放这将来的消息
![这里当有图]()
在SMP VM中，发送进程不会为了接受进程调用垃圾回收。超过64字节的二进制数据将被存放在共有堆中，被所有的进程共享。ets表也被存放在共有堆中。图3.1说明了这些主要的内存区域（这儿也有其他的内存区域，例如原子表）。

图3.1显示，erlang进程的栈和堆位于连续的内存空间，它们统一分配和管理。从系统级别的进程或线程来说，这个区域属于堆，这意味着erlang进程的栈跟堆都存放在虚拟机的堆空间上。在这个区域中，堆开始于低地址并向上增长，栈开始于高地址并向下增长。堆溢出可以通过测试堆顶和栈顶来探测。

堆被用于存放一些复杂的数据结构例如元组，列表和大整形，栈被用于存放一些简单的结构和引用，引用指向堆中的复杂结构。没有指针从堆指向栈，这使得垃圾回收很方便。图3.2显示一个例子列表和元组在栈和堆中如何存放
。

erlang是一个动态类型的语言。在运行的时候，一个变量和它的类型联系在一起。在编译期，数据的类型不能够知道。在内部的实现，有一个tag位标识了数据的类型。在32位机器上，一个字是32位，它有2位标示tag，在64位机器上，一个字是64位，它用6位标示一个tag。对于一个元组，栈上有一个指针指向堆中的对象。对象存在连续的内存区域。它可以是任何erlang的有效类型，甚至是一个元组或者一个列表。元组中也包含一个头部指示元组的长度。元组的元素能够被非常快的定位到，作为一个数组的结构。

![图3.2]()
在其他方面，一个列表被实现为一个链表。没有头部指示链表的长度。列表中的每一个元素都指向下一个元素，除非下一个元素是空指针。两个元素或许被堆中的其他数据分割开来在erlang中列表用的非常多，因为它能被添加，连接和分割。图3.2 列表C显示了列表在内存中的布局，它通过添加列表A到列表B后构造。首先所有的列表B的元素被复制，最后的指针被改变为指向列表A的第一个元素。如果列表B非常长，这个操作将花费很长时间才能完成。所以最好的方式是填加一个长列表到短列表的后面。合适的列表操作是写出高效的erlang应用的必须方式。从列表的结构，我们可以知道得到列表的大小，必须遍历所有的元素。

列表C的结构显示，进程中两个变量使用了相同的内存。但是这不会在进程之间。如果列表c被通过消息发送到其他进程，整个列表将被复制。接受进程的消息不能有一个指针指向发送者进程的列表A。另外，如果列表A在之后再次被发送到同一个进程，这个列表a的内容将被再次复制。这将使得接受进程比发送者使用更多的内存。

一个erlang进程开始是一个很小的栈和堆，这是系统能够支持大量的进程。配置的缺省值是233字节。通常，erlang进程期望短存活并且有少量的数据。当一个进程的堆中没有足够的自由内存，它将调用垃圾回收，如果需要的内存大于释放的内存，那么堆将增长。每一个进程的堆的垃圾回收都是独立的。当一个调度器垃圾回收一个进程，其他调度器能够保持执行其他进程。私有堆的结构能够高效的从发送者的堆中复制消息到接受者的堆中。这个每一个进程有着独立的垃圾回收架构能够较少的打扰系统运行，并且当一个进程退出的时候，内存很容易回收。虚拟机缺省使用私有堆架构，但是erlang虚拟机也能通过编译使用混合架构。在混合模式下，私有数据被存放在私有堆上，消息被存放在共有堆上，并被所有进程共享。在这种模式下，消息不在需要复制并且消息传送将花费常量时间，仅仅传送一个消息的指针。但是这个混合堆的问题是：如果没有非常复制的垃圾回收机制，那么回收共有堆就必须停止所有进程的执行并且由于垃圾回收的根集合包含了所有进程的数据，所以垃圾回收也将花费更长的时间。它需要一个增量式垃圾回收机制。当前的erlang虚拟机的混合堆版本还是实验性的并且不支持SMP，它也缺乏编译支持。编译器必须预测哪个变量将被用于发送消息然后在共有堆中给它们分配空间。

###3.2 消息传输

在同一个节点中的两个进程间的消息传输的实现是通过复制发送进程堆的消息，再放置到接受进程堆中。在SMP虚拟机中，当发送消息时，如果接受进程在其他调度器中执行，那么接受进程的堆不能存放这个新的消息，或者其他消息正在被其他进程复制(此处略有不通，可看原文)，那么发送进程将为接受进程分配一个分配一个临时的堆碎片存放这个新消息。一个进程的堆碎片将在垃圾回收期间被合并到私有堆。在复制消息之后，管理的数据结构包含了一个指针指向具体的消息，而这个消息被放在接受进程的消息队列的末尾。然后，接受进程将被唤醒并被添加到运行队列，如果它处于挂起状态的话。在SMP虚拟机中，进程的消息队列实现上由两个队列组成。其他进程发送的消息被放在外部或者公开队列的末尾。（译者：也就是说有两个队列，一个是自己给自己放的，一个是其他进程发的？）。这个消息队列为了达到互斥的效果使用了锁进行保护(看3.4节)。当取回消息为了减少获取锁的开销，进程通常工作在私有队列，但是如果它不能在私有堆中找到一个匹配，这个公开消息队列的消息将被移除被添加到私有队列的后面。之后这些消息能够被匹配。这个公开队列在序列化的erlang虚拟机中不再被需要，此时这里仅有一个队列。

如果一个进程发送消息给它自己，这个消息不需要被复制。仅仅需要一个新的管理数据结构的指针指向这个已经分配的消息。在进程的公开队列的消息管理数据结构中不能保护指向堆的指针，这是因为数据在公开队列中不会被放在垃圾回收的根集合中。如果一个共有队列的结构中有一个指针指向进程的堆，那么当消息被移动到私有队列中，这个指针将被包含在垃圾回收的根集合中，其他情况下都将丢失这部分数据。但是如果消息在管理数据指向堆之前被添加，早于公开队列必须被合并到私有队列之前。这个顺序将使得这个消息的到达总是被维护的(译者：这话我也不知道什么意思，翻译过来就这样)。在堆碎片中的消息总是在垃圾回收期间被存放。进行的消息队列是PCB的一部分，而不是存放在进程堆中。

一个进程执行`receive`命令将检查消息队列的消息是否匹配特殊的项式。如果匹配，相应的管理数据将从队列中移除，相关的指令被执行。如果没有匹配的消息，则进程被挂起。如果接受到新的消息并被被调度运行时将被唤醒，新的消息将被检查这些匹配模式。如果不匹配，进程将被再次挂起。

消息通过复制传递，erlang期望消息非常小。这个原则也被用于传递参数给新起的进程。参数不能被存放在本地类型给不同的进程共享。所以当每次新创建一个进程，参数就会被复制。

消息传递能够影响many-core处理器上的erlang虚拟机的可扩展性。首先，在many-core系统中访问一个进程的外部消息队列必须同步，这会造成开销。第二，分配和释放消息分配的内存时，消息的管理结构需要同步。一个节点的所有的调度器线程需要内存时都从操作系统进程共有的内存空间分配内存，这需要被保护。一个消息的内存块或者一个消息管理结构从内存池中分配内存，这个内存仅能被正在发生的调度器分配。但是如果消息或者管理数据结果通过其他调度器发送到进程，这个内存块被释放且返回给初始内存池，释放内存块到内存池的期间，仍然需要同步来阻止多调度器的竞争。第三，如果大量进程并行的运行，它们的消息能被一定的顺序发送，这个顺序跟它们发送消息到erlang虚拟机的顺序有点不同。当消息以不同的顺序到达，它们在消息匹配时花费的时间相差极大，这意味着工作量会改变。那么在大量的消息传输或者高频率的传递消息会影响应用的可扩展性。也会影响消息如何发送和接受。


### 3.3 调度
这里有四种类型的工作必须被调度，进程，端口，连接设备和系统等级的活动。系统等级的任务包括io检查，例如：用户在终端输入的时候。连接设备是另外一种机制，提供erlang调用其他程序语言写的程序。和端口一样外部的程序在一个独立的OS进程中执行，外部程序作为一个连接设备运行在erlang节点的os进程中的一个线程中。它也依赖端口与其他erlang进程进行交互。下面的描述主要集中在调度进程。

####3.3.1 概述
erlang调度基于规约计数，规约计数作为一种测量执行时间的方法。一个规约数大致与一次函数调用相等，每一次函数调用或许花费不同的时间，所以实际上两次规约数的周期并不一样。当一个进程被调度运行，它被分配一定数量的规约数（在R13B04下默认是2000规约数），然后被运行执行。这个进程能够被一直执行直到花费完所有的规约数或者暂停等待消息。一个被暂停等待消息的进程会在消息到底或者超时时被重新调度，重新调度的进程或者新的进程被放在当前运行队列的末尾。挂起的进程不存放在运行队列中。

这里有四种进程优先级：最大优先级，高优先级，正常优先级和低优先级。每一个进程会有一个最大优先级的队列和高优先级队列。正常优先级与低优先级共用一个队列。所以调度器的进程运行队列共有3个。当然，这里也有一个端口队列。在接下来的部分，每一个进程或者端口的优先级队列被称为优先队列。总的来说，一个调度器共有4个优先队列（3个进程，1个端口）所有的进程和端口都能被运行。一个运行队列的所有进程和端口的个数作为运行队列长度。在同一个优先队列中的进行按round-robin序执行。round-robin顺序是指调度器分配一定的时间片给每一个进程并且进程有相同的执行优先级。

一个调度器选择最大优先级队列中的进程执行，直到它为空。然后对高优先级队列做同样的事情。当最大优先级队列和高优先级队列中没有进程时，正常优先级队列中的进程将被执行。低优先级和正常优先级进程使用同一个队列，在执行一定数量正常优先级的进程之前，低优先级被跳过。

调度器另一个重要的任务是在多核处理器或者多核心上平衡工作量。分享工作和偷工作被使用（为了平衡工作量）。通常情况下，工作量在一定的频率和周期下被检查和分享。在一个周期中，偷工作是为了平衡工作量。每一个周期在众多调度器中的一个都会检查所有调度器（或者运行队列）加载条件，它会探测到激活调度器的个数，这是因为下一个周期基于当前周期加载的个数。它也会计算迁移限制，这个限制是为了进程和端口的个数，每一个调度器的优先队列都基于系统上队列中加载和有效的进程和端口。然后，它建立迁移路径指示哪个优先队列应该推送工作到其他优先队列和哪个优先队列应该从其他优先队列中获取工作。

在进程和端口的迁移关系定下来后，优先队列将从对应的优先队列获取进程或者端口在调度时间槽期间，对应的优先队列将推送任务到其他队列。调度时间是交错执行进程，端口和其它任务。当一个系统正在加载并且一些调度器处于非活动状态，（这个工作主要被非活动调度器推动？？）the work is mainly pushed by inactive schedulers。非活动调度器将待命，直到所有工作被推出去。但是当系统是全部加载并且所有有效的调度器是活动状态，主要的工作是有少量的工作的调度器去拉（pull）取工作。

如果一个活跃的调度器没有工作，并且不能再从其他调度器拉取工作，它尝试从其他调度器偷取工作。如果偷取也没有成功，并且没有系统等级的活动，这个调度线程将变为等待状态。它等待系统级的活动或者正常的工作。在正常等待状态下，它旋转变量为了等待其他调度器的唤醒。如果没有调度器唤醒它，这个调度线程将被锁在一个条件变量。当一个调度器线程被锁住后，将花费长时间才能唤醒它。一个有着过高工作量的调度去将唤醒其他处于自旋或者锁着状态的调度器。流程图在图3.3中显示了在SMP虚拟机中调度算法的主要的一部分。平衡检查和工作窃取将在剩余的章节进行详细的介绍。

####3.3.2 调度器的个数
当任意调度器的计数到达0的时候，erlang系统的加载将在调度期间被检查。每一个调度器的计数每次在一定数量的规约数被进程或者端口执行完后递减。调度器的计数在每次检查后被重置成一个值（默认是2000*2000）。
